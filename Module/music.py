import asyncio

from disnake.ext import commands
from utils.ClientUser import ClientUser
from disnake import Embed, ApplicationCommandInteraction, Option

from mafic import Track, Playlist, TrackEndEvent, EndReason
from musicCore.player import MusicPlayer, LOADFAILED, QueueInterface
from musicCore.check import check_voice, has_player
from utils.conv import trim_text, time_format

class Music(commands.Cog):
    def __init__(self, bot):
        self.bot: ClientUser = bot

    @check_voice()
    @commands.slash_command(name="play", description="Ch∆°i m·ªôt b·∫£n nh·∫°c", options=[
        Option(name="search",
               description="T√¨m ki·∫øm b√†i h√°t b·∫±ng t√™n ho·∫∑c url",
               required=True)])
    async def play(self, ctx: ApplicationCommandInteraction, search: str):
        await ctx.response.defer()

        player: MusicPlayer = ctx.author.guild.voice_client
        loaded = True

        if player is None:
            try:
                player: MusicPlayer = await ctx.author.voice.channel.connect(cls=MusicPlayer)
                loaded = False
            except asyncio.TimeoutError:
                return await ctx.edit_original_response("ƒê√£ x·∫£y ra s·ª± c·ªë khi k·∫øt n·ªëi v√†o k√™nh tho·∫°i c·ªßa b·∫°n")

        player.NotiChannel = ctx.channel

        try:
            result = await player.fetch_tracks(search)
            if isinstance(result, Playlist):
                total_time = 0
                for track in result.tracks:
                    player.queue.add_next_track(track)
                    if not track.stream: total_time += track.length

                thumbnail_track = result.tracks[0]
                embed = Embed(
                    title=trim_text("[Playlist] " + thumbnail_track.title, 32),
                    url=thumbnail_track.uri,
                    color=0xFFFFFF
                )
                embed.description = f"``{thumbnail_track.source.capitalize()} | {result.tracks.__len__()} b√†i h√°t | {time_format(total_time)}`"
                embed.set_thumbnail(result.tracks[0].artwork_url)

            elif isinstance(result, list):
                track: Track = result[0]
                player.queue.add_next_track(track)
                embed = Embed(
                    title=trim_text(track.title, 32),
                    url=track.uri,
                    color=0xFFFFFF
                )
                embed.description = f"`{track.source.capitalize()} | {track.author}"
                if track.stream:
                    embed.description += " | üî¥ LIVESTREAM`"
                else:
                    embed.description += f" | {time_format(track.length)}`"
                embed.set_thumbnail(track.artwork_url)
            else:
                embed = LOADFAILED
        except:
            embed = LOADFAILED
            self.bot.logger.error(f"ƒê√£ c√≥ l·ªói x·∫£y ra khi t√¨m ki·∫øm b√†i h√°t: {search} (ID m√°y ch·ªß: {ctx.guild_id})")
        await ctx.edit_original_response(embed=embed)

        if not loaded:
            await player.process_next()

    @commands.cooldown(1, 10, commands.BucketType.guild)
    @commands.slash_command(name="stop", description="D·ª´ng ph√°t nh·∫°c")
    @commands.guild_only()
    @has_player()
    @check_voice()
    async def stop(self, ctx: ApplicationCommandInteraction):
        await ctx.response.defer()
        player: MusicPlayer = ctx.author.guild.voice_client
        await player.stop()
        await player.disconnect(force=True)
        await ctx.edit_original_response(
            embed=Embed(
                title="‚èπÔ∏è ƒê√£ d·ª´ng ph√°t nh·∫°c",
                color=0x00FFFF
            )
        )

    @commands.cooldown(3, 10, commands.BucketType.guild)
    @commands.slash_command(name="pause", description="T·∫°m d·ª´ng b√†i h√°t")
    @commands.guild_only()
    @has_player()
    @check_voice()
    async def pause(self, inter: ApplicationCommandInteraction):
        await inter.response.defer()
        player: MusicPlayer = inter.author.guild.voice_client
        player.NotiChannel = inter.channel
        if player.paused:
            await player.resume()
            await inter.edit_original_response("ƒê√£ ti·∫øp t·ª•c ph√°t")
        else:
            await player.pause()
            await inter.edit_original_response(f"ƒê√£ t·∫°m d·ª´ng b√†i h√°t")

    @commands.cooldown(3, 10, commands.BucketType.guild)
    @commands.slash_command(name="next", description="Ph√°t b√†i h√°t ti·∫øp theo")
    @commands.guild_only()
    @has_player()
    @check_voice()
    async def next(self, inter: ApplicationCommandInteraction):
        await inter.response.defer()
        player: MusicPlayer = inter.author.guild.voice_client
        player.NotiChannel = inter.channel
        await player.playnext()
        await inter.edit_original_response(
            embed=Embed(
                title="‚è≠Ô∏è ƒê√£ chuy·ªÉn sang b√†i h√°t ti·∫øp theo",
                color=0x00FFFF
            )
        )

    @commands.cooldown(3, 10, commands.BucketType.guild)
    @has_player()
    @check_voice()
    @commands.slash_command(name="previous", description="Ph√°t l·∫°i b√†i h√°t tr∆∞·ªõc ƒë√≥")
    async def prev(self, inter: ApplicationCommandInteraction):
        await inter.response.defer()
        player: MusicPlayer = inter.author.guild.voice_client
        player.NotiChannel = inter.channel
        result = await player.playprevious()
        if result:
            await inter.edit_original_response(
                embed=Embed(
                    title="‚èÆÔ∏è ƒê√£ quay l·∫°i b√†i h√°t tr∆∞·ªõc ƒë√≥",
                    color=0x00FFFF
                )
            )
        else:
            await inter.edit_original_response(
                embed=Embed(
                    title="‚ö†Ô∏è Kh√¥ng c√≥ b√†i h√°t n√†o ƒë√£ ph√°t tr∆∞·ªõc ƒë√≥",
                    color=0xFFFF00
                )
            )

    @commands.cooldown(1, 20, commands.BucketType.guild)
    @has_player()
    @check_voice()
    @commands.slash_command(name="queue", description="Hi·ªÉn th·ªã danh s√°ch ch·ªù")
    async def show_queue(self, inter: ApplicationCommandInteraction):
        await inter.response.defer()
        player: MusicPlayer = inter.author.guild.voice_client
        if not player.queue.next_track:
            return await inter.edit_original_response("Kh√¥ng c√≥ b√†i h√°t trong h√†ng ƒë·ª£i")

        view = QueueInterface(player=player)
        embed = view.embed

        kwargs = {
            "embed": embed,
            "view": view
        }
        try:
            func = inter.followup.send
            kwargs["ephemeral"] = True
        except AttributeError:
            func = inter.send
            kwargs["ephemeral"] = True

        view.message = await func(**kwargs)

        await view.wait()

    @commands.cooldown(1, 20, commands.BucketType.guild)
    @has_player()
    @check_voice()
    @commands.slash_command(name="clear_queue", description="Xo√° danh s√°ch ch·ªù")
    async def clear_queue(self, inter: ApplicationCommandInteraction):
        await inter.response.defer()
        player: MusicPlayer = inter.author.guild.voice_client
        player.queue.clear_queue()
        await inter.send(embed=Embed(
            title="‚úÖ ƒê√£ xo√° t·∫•t c·∫£ b√†i h√°t trong danh s√°ch ch·ªù",
            color=0x00FF00
        ))

    @commands.Cog.listener()
    async def on_track_end(self, event: TrackEndEvent[MusicPlayer]):
        player = event.player
        reason = event.reason
        if reason == EndReason.FINISHED:
            await player.process_next()
        elif reason == EndReason.LOAD_FAILED:
            await player.NotiChannel.send(f"ƒê√£ c√≥ l·ªói x·∫£y ra khi t·∫£i b√†i h√°t {player.queue.is_playing.title}")
            self.bot.logger.warning(f"T·∫£i b√†i h√°t ƒë∆∞·ª£c y√™u c·∫ßu ·ªü m√°y ch·ªß {player.guild.id} th·∫•t b·∫°i")
            await player.playnext()

def setup(bot: ClientUser):
    bot.add_cog(Music(bot))